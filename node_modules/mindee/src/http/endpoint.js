"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Endpoint_instances, _Endpoint_cutDocPages, _Endpoint_predictReqPost, _Endpoint_predictAsyncReqPost, _Endpoint_documentQueueReqGet, _Endpoint_documentGetReq;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Endpoint = void 0;
const https_1 = require("https");
const url_1 = require("url");
const form_data_1 = __importDefault(require("form-data"));
const logger_1 = require("../logger");
const base_1 = require("../input/base");
const error_1 = require("./error");
/**
 * Endpoint object class wrapper.
 */
class Endpoint {
    constructor(urlName, owner, version, settings) {
        _Endpoint_instances.add(this);
        this.owner = owner;
        this.urlName = urlName;
        this.version = version;
        this.settings = settings;
        this.urlRoot = `/v1/products/${owner}/${urlName}/v${version}`;
    }
    /**
     * Sends a prediction to the API and parses out the result.
     * Throws an error if the server's response contains one.
     * @param params parameters relating to prediction options.
     * @category Synchronous
     * @returns a `Promise` containing parsing results.
     */
    async predict(params) {
        await params.inputDoc.init();
        if (params.pageOptions !== undefined) {
            await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_cutDocPages).call(this, params.inputDoc, params.pageOptions);
        }
        const response = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_predictReqPost).call(this, params.inputDoc, params.includeWords, params.cropper);
        const statusCode = response.messageObj.statusCode;
        if (statusCode === undefined || statusCode >= 400) {
            (0, error_1.handleError)(this.urlName, response, statusCode, response.messageObj?.statusMessage);
        }
        return response;
    }
    /**
     * Enqueues a prediction to the API.
     * Throws an error if the server's response contains one.
     * @param params parameters relating to prediction options.
     * @category Asynchronous
     * @returns a `Promise` containing queue data.
     */
    async predictAsync(params) {
        await params.inputDoc.init();
        if (params.pageOptions !== undefined) {
            await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_cutDocPages).call(this, params.inputDoc, params.pageOptions);
        }
        const response = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_predictAsyncReqPost).call(this, params.inputDoc, params.includeWords, params.cropper);
        const statusCode = response.messageObj.statusCode;
        if (statusCode === undefined || statusCode >= 400) {
            (0, error_1.handleError)(this.urlName, response, statusCode, response.messageObj?.statusMessage);
        }
        return response;
    }
    /**
     * Requests the results of a queued document from the API.
     * Throws an error if the server's response contains one.
     * @param params parameters relating to prediction options.
     * @category Asynchronous
     * @returns a `Promise` containing the parsed result.
     */
    async getQueuedDocument(queueId) {
        const queueResponse = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_documentQueueReqGet).call(this, queueId);
        const queueStatusCode = queueResponse.messageObj.statusCode;
        if (queueStatusCode === undefined ||
            queueStatusCode < 200 ||
            queueStatusCode > 400) {
            (0, error_1.handleError)(this.urlName, queueResponse, queueStatusCode, queueResponse.messageObj?.statusMessage);
        }
        if (queueStatusCode === 302 &&
            queueResponse.messageObj.headers.location !== undefined) {
            const docId = queueResponse.messageObj.headers.location.split("/").pop();
            if (docId !== undefined) {
                return await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_documentGetReq).call(this, docId);
            }
        }
        return queueResponse;
    }
    /**
     * Send a file to a prediction API.
     * @param input
     * @param predictUrl
     * @param includeWords
     * @param cropper
     */
    sendFileForPrediction(input, predictUrl, includeWords = false, cropper = false) {
        return new Promise((resolve, reject) => {
            const searchParams = new url_1.URLSearchParams();
            if (cropper) {
                searchParams.append("cropper", "true");
            }
            const form = new form_data_1.default();
            if (input instanceof base_1.LocalInputSource && input.fileObject instanceof Buffer) {
                form.append("document", input.fileObject, {
                    filename: input.filename,
                });
            }
            else {
                form.append("document", input.fileObject);
            }
            if (includeWords) {
                form.append("include_mvision", "true");
            }
            const headers = { ...this.settings.baseHeaders, ...form.getHeaders() };
            let path = `${this.urlRoot}/${predictUrl}`;
            if (searchParams.keys.length > 0) {
                path += `?${searchParams}`;
            }
            const options = {
                method: "POST",
                headers: headers,
                hostname: this.settings.hostname,
                path: path,
            };
            const req = this.readResponse(options, resolve, reject);
            form.pipe(req);
            // potential ECONNRESET if we don't end the request.
            req.end();
        });
    }
    /**
     * Reads a response from the API and processes it.
     * @param options options related to the request itself.
     * @param resolve the resolved response
     * @param reject promise rejection reason.
     * @returns the processed request.
     */
    readResponse(options, resolve, reject) {
        logger_1.logger.debug(`${options.method}: https://${options.hostname}${options.path}`);
        const req = (0, https_1.request)(options, function (res) {
            // when the encoding is set, data chunks will be strings
            res.setEncoding("utf-8");
            let responseBody = "";
            res.on("data", function (chunk) {
                logger_1.logger.debug("Receiving data ...");
                responseBody += chunk;
            });
            res.on("end", function () {
                logger_1.logger.debug("Parsing the response ...");
                // handle empty responses from server, for example in the case of redirects
                if (!responseBody) {
                    responseBody = "{}";
                }
                try {
                    const parsedResponse = JSON.parse(responseBody);
                    try {
                        resolve({
                            messageObj: res,
                            data: parsedResponse,
                        });
                    }
                    catch (error) {
                        logger_1.logger.error("Could not construct the return object.");
                        reject(error);
                    }
                }
                catch (error) {
                    logger_1.logger.error("Could not parse the return as JSON.");
                    logger_1.logger.debug(responseBody);
                    resolve({
                        messageObj: res,
                        data: { reconstructedResponse: responseBody },
                    });
                }
            });
        });
        req.on("error", (err) => {
            reject(err);
        });
        return req;
    }
}
exports.Endpoint = Endpoint;
_Endpoint_instances = new WeakSet(), _Endpoint_cutDocPages = 
/**
 * Cuts a document's pages according to the given options.
 * @param inputDoc input document.
 * @param pageOptions page cutting options.
 */
async function _Endpoint_cutDocPages(inputDoc, pageOptions) {
    if (inputDoc instanceof base_1.LocalInputSource && inputDoc.isPdf()) {
        await inputDoc.cutPdf(pageOptions);
    }
}, _Endpoint_predictReqPost = function _Endpoint_predictReqPost(input, includeWords = false, cropper = false) {
    return this.sendFileForPrediction(input, "predict", includeWords, cropper);
}, _Endpoint_predictAsyncReqPost = function _Endpoint_predictAsyncReqPost(input, includeWords = false, cropper = false) {
    return this.sendFileForPrediction(input, "predict_async", includeWords, cropper);
}, _Endpoint_documentQueueReqGet = function _Endpoint_documentQueueReqGet(queueId) {
    return new Promise((resolve, reject) => {
        const options = {
            method: "GET",
            headers: this.settings.baseHeaders,
            hostname: this.settings.hostname,
            path: `${this.urlRoot}/documents/queue/${queueId}`,
        };
        const req = this.readResponse(options, resolve, reject);
        // potential ECONNRESET if we don't end the request.
        req.end();
    });
}, _Endpoint_documentGetReq = function _Endpoint_documentGetReq(documentId) {
    return new Promise((resolve, reject) => {
        const options = {
            method: "GET",
            headers: this.settings.baseHeaders,
            hostname: this.settings.hostname,
            path: `${this.urlRoot}/documents/${documentId}`,
        };
        const req = this.readResponse(options, resolve, reject);
        // potential ECONNRESET if we don't end the request.
        req.end();
    });
};
